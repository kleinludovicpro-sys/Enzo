<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>6e ‚Äî Atelier R√©daction (ludique + points)</title>
  <style>
    :root{
      --bg:#0b1220; --card:#101a2f; --muted:#9bb0d0; --text:#eaf1ff;
      --accent:#63e6be; --accent2:#74c0fc; --warn:#ffd43b; --bad:#ff6b6b;
      --ok:#51cf66; --border:rgba(255,255,255,.08);
      --shadow: 0 18px 50px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(18,32,71,.9), transparent),
        radial-gradient(900px 500px at 95% 15%, rgba(29,96,124,.35), transparent),
        var(--bg);
      color:var(--text);
    }
    header{
      padding:16px 14px;
      border-bottom:1px solid var(--border);
      position:sticky; top:0;
      backdrop-filter: blur(10px);
      background:rgba(11,18,32,.72);
      z-index:5;
    }
    header .top{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
    }
    header h1{margin:0;font-size:16px; letter-spacing:.2px}
    header p{margin:6px 0 0; color:var(--muted); font-size:12.5px; line-height:1.35}
    .wrap{max-width:1100px;margin:0 auto;padding:14px;}
    .tabs{display:flex; gap:8px; flex-wrap:wrap; margin:12px 0 16px;}
    .tab{
      border:1px solid var(--border);
      background:rgba(16,26,47,.65);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:750;
      font-size:13px;
      box-shadow: 0 8px 22px rgba(0,0,0,.15);
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
    }
    .tab:hover{transform:translateY(-1px)}
    .tab.active{
      outline:2px solid rgba(99,230,190,.35);
      border-color:rgba(99,230,190,.35);
      background:rgba(99,230,190,.10);
    }

    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:12px;}
    @media (max-width: 920px){ .grid{grid-template-columns:1fr;} header{position:static;} }

    .card{
      background:rgba(16,26,47,.72);
      border:1px solid var(--border);
      border-radius:18px;
      padding:14px;
      box-shadow: var(--shadow);
    }
    .card h2{margin:0 0 10px; font-size:16px}
    .card h3{margin:14px 0 8px; font-size:14px; color:#d8e5ff}
    .muted{color:var(--muted); font-size:13px; line-height:1.35}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border:1px solid var(--border);
      border-radius:999px; background:rgba(255,255,255,.03); font-size:13px;
    }
    .score{font-weight:900; color:var(--accent); font-size:16px}
    .btn{
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.primary{background:rgba(99,230,190,.14); border-color:rgba(99,230,190,.22);}
    .btn.secondary{background:rgba(116,192,252,.12); border-color:rgba(116,192,252,.22);}
    .btn.danger{background:rgba(255,107,107,.12); border-color:rgba(255,107,107,.22);}

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    textarea, input[type="text"]{
      width:100%;
      background:rgba(255,255,255,.03);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:14px;
      padding:12px;
      font-size:14px;
      outline:none;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
    }
    textarea{min-height:180px; resize:vertical; line-height:1.45}
    .q{
      padding:10px 10px;
      border-radius:14px;
      border:1px solid var(--border);
      margin:10px 0;
      background:rgba(255,255,255,.02);
    }
    .q .stem{font-weight:850; margin-bottom:8px;}
    label.opt{
      display:flex; gap:10px; align-items:flex-start;
      padding:6px 6px; cursor:pointer; color:#dbe7ff;
      border-radius:12px;
    }
    label.opt:hover{background:rgba(255,255,255,.03)}
    label.opt input{margin-top:3px;}
    .tag{
      display:inline-block; padding:4px 8px; border-radius:999px;
      font-size:12px; border:1px solid var(--border); color:#dbe7ff; background:rgba(255,255,255,.03);
    }
    .kpi{display:grid; grid-template-columns:repeat(3,1fr); gap:10px;}
    @media (max-width: 560px){ .kpi{grid-template-columns:1fr;} }
    .kpi .box{
      padding:10px;border-radius:16px;border:1px solid var(--border);
      background:rgba(255,255,255,.02)
    }
    .good{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    details{border:1px solid var(--border); border-radius:14px; padding:10px; background:rgba(255,255,255,.02);}
    details summary{cursor:pointer; font-weight:850;}
    .small{font-size:12px; color:var(--muted)}
    .hr{height:1px;background:var(--border); margin:12px 0;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .banner{
      border:1px solid rgba(99,230,190,.22);
      background:linear-gradient(135deg, rgba(99,230,190,.14), rgba(116,192,252,.10));
      border-radius:18px;
      padding:12px;
      box-shadow: var(--shadow);
    }
    .progress{
      height:10px; border-radius:999px; border:1px solid var(--border);
      background:rgba(255,255,255,.03); overflow:hidden;
    }
    .progress > div{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(99,230,190,.95), rgba(116,192,252,.85));
      border-radius:999px;
      transition: width .4s ease;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      font-size:13px; font-weight:850;
    }
    .toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(16,26,47,.92);
      border:1px solid rgba(99,230,190,.22);
      color:var(--text);
      padding:10px 12px; border-radius:14px;
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      max-width:min(92vw, 640px);
      z-index:50;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-6px);}
    .spark{
      display:inline-block;
      filter: drop-shadow(0 10px 18px rgba(99,230,190,.25));
    }
  </style>
</head>
<body>
<header>
  <div class="top">
    <div>
      <h1>üß† Atelier R√©daction 6e ‚Äî version ludique</h1>
      <p>Le√ßon compl√®te + QCM not√© + ateliers not√©s + feux tricolores + temps pass√© + rapport parent imprimable.</p>
    </div>
    <div class="pill">
      <span class="spark">üè∞</span>
      <span>Niveau : <b id="level">1</b></span>
      <span>‚Ä¢</span>
      <span>XP : <b id="xp">0</b></span>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="tabs">
    <button class="tab active" data-tab="lesson">üìö Le√ßon</button>
    <button class="tab" data-tab="qcm">‚úÖ QCM</button>
    <button class="tab" data-tab="workshops">‚úçÔ∏è Ateliers</button>
    <button class="tab" data-tab="report">üèÅ Bilan Parent</button>
  </div>

  <div id="view"></div>
</div>

<div id="toast" class="toast"></div>

<script>
/* =========================================================
   1) CONTENU DE COURS (issu de tes documents)
========================================================= */
const LESSON = {
  methode: [
    "Lis plusieurs fois la consigne et rep√®re les verbes (d√©crire / raconter / imaginer / continuer‚Ä¶).",
    "Observe le texte : personnages, lieu, moment, but (faire rire / √©mouvoir / effrayer / r√©fl√©chir‚Ä¶), temps (pass√©/pr√©sent), point de vue (1re/3e).",
    "Au brouillon : note les id√©es, puis organise-les en plan. Fais des paragraphes pour marquer les p√©rip√©ties.",
    "R√©dige en suivant ton plan : phrases compl√®tes, vocabulaire soign√©, orthographe.",
    "Relis : sens des phrases + construction + accords + ponctuation, puis recopie au propre.",
  ],
  dialogue: [
    "√Ä chaque changement de personnage : retour √† la ligne + tiret.",
    "Tu peux ajouter des incises (dit-il, r√©pondit-elle‚Ä¶) pour indiquer qui parle.",
    "Utilise des verbes de parole vari√©s : demander, r√©pliquer, s‚Äôexclamer, murmurer, protester‚Ä¶",
    "Le dialogue doit faire avancer l‚Äôaction (pas du blabla).",
  ],
  description: [
    "√âvite ‚Äúil y a‚Äù et le verbe ‚Äú√™tre‚Äù quand tu peux : pr√©f√®re des verbes pr√©cis.",
    "Ajoute des verbes de perception : voir, entendre, sentir, toucher, go√ªter‚Ä¶",
    "Enrichis les groupes nominaux : adjectifs + compl√©ments du nom.",
    "Situe dans l‚Äôespace : ici, l√†-bas, au-dessus, derri√®re, √† droite‚Ä¶",
    "Au pass√© : description souvent √† l‚Äôimparfait. Au pr√©sent : description au pr√©sent.",
  ],
  connecteurs: {
    "Expliquer / justifier": ["en effet", "car", "parce que", "puisque"],
    "Opposer / nuancer": ["mais", "pourtant", "cependant", "n√©anmoins", "toutefois", "au contraire", "en revanche", "quand m√™me"],
    "Ajouter": ["aussi", "et", "√©galement", "de m√™me", "de plus", "en plus", "non seulement ‚Ä¶ mais encore"],
    "Reformuler": ["autrement dit", "en un mot", "c‚Äôest-√†-dire", "en d‚Äôautres termes", "en r√©sum√©", "en somme"],
    "Pr√©senter / illustrer": ["par exemple", "ainsi", "notamment", "comme", "pour preuve", "√† l‚Äôimage de"],
    "Conclure": ["c‚Äôest pourquoi", "par cons√©quent", "ainsi", "enfin", "finalement"],
  },
  poesie: [
    "Une strophe = un groupe de vers (on saute une ligne entre les strophes).",
    "Types de vers : octosyllabe (8 syllabes), d√©casyllabe (10), alexandrin (12).",
    "Rimes : plates (AABB), crois√©es (ABAB), embrass√©es (ABBA).",
    "Sonorit√©s : allit√©rations (consonnes), assonances (voyelles), r√©p√©titions (anaphores).",
    "Images : comparaisons, m√©taphores, figures de style.",
  ],
};

/* =========================================================
   2) QCM NOT√â (corrig√© + explications)
========================================================= */
const QCM = [
  {
    cat:"Dialogue",
    stem:"Dans un r√©cit, √† chaque changement de personnage dans un dialogue, on‚Ä¶",
    options:[
      "reste sur la m√™me ligne et on met une virgule",
      "va √† la ligne et on met un tiret",
      "met un point-virgule et on continue",
      "met des parenth√®ses"
    ],
    answer:1,
    explain:"Dialogue de r√©cit : retour √† la ligne + tiret quand le personnage change."
  },
  {
    cat:"Dialogue",
    stem:"Quel choix est le plus adapt√© pour enrichir un dialogue ?",
    options:[
      "Utiliser toujours le verbe ‚Äúdire‚Äù",
      "√âviter toute action",
      "Varier les verbes de parole (murmurer, r√©pliquer, s‚Äôexclamer‚Ä¶)",
      "Ne pas indiquer qui parle"
    ],
    answer:2,
    explain:"On varie les verbes de parole et on peut mettre des incises."
  },
  {
    cat:"Description",
    stem:"Pour une description plus pr√©cise, on √©vite surtout‚Ä¶",
    options:[
      "les adjectifs",
      "‚Äúil y a‚Äù et le verbe ‚Äú√™tre‚Äù (quand c‚Äôest possible)",
      "les verbes de perception",
      "les connecteurs spatiaux"
    ],
    answer:1,
    explain:"On cherche des verbes plus pr√©cis que ‚Äú√™tre/il y a‚Äù et un vocabulaire riche."
  },
  {
    cat:"Connecteurs",
    stem:"Le connecteur ‚Äún√©anmoins‚Äù sert surtout √†‚Ä¶",
    options:["ajouter", "opposer / nuancer", "conclure", "illustrer"],
    answer:1,
    explain:"‚ÄúN√©anmoins‚Äù = opposition / nuance."
  },
  {
    cat:"Po√©sie",
    stem:"Une strophe, c‚Äôest‚Ä¶",
    options:[
      "un type de rime",
      "un ensemble de vers",
      "une comparaison",
      "un connecteur logique"
    ],
    answer:1,
    explain:"Strophe = groupe de vers."
  },
  {
    cat:"Po√©sie",
    stem:"Des rimes crois√©es, c‚Äôest plut√¥t‚Ä¶",
    options:["AABB", "ABBA", "ABAB", "AAAA"],
    answer:2,
    explain:"Rimes crois√©es : ABAB."
  },
  {
    cat:"M√©thode",
    stem:"Avant d‚Äô√©crire, la premi√®re √©tape utile est de‚Ä¶",
    options:[
      "copier directement au propre",
      "lire la consigne et rep√©rer ce qu‚Äôon doit faire",
      "compter les lignes de la feuille",
      "inventer la fin sans plan"
    ],
    answer:1,
    explain:"On commence par comprendre la consigne (verbes, attentes, contraintes)."
  },
];

/* =========================================================
   3) TEXTES SUPPORT + ATELIERS
========================================================= */
const TEXTS = [
  {
    title:"Texte support 1 (r√©cit ‚Äî court)",
    body:
`Hier soir, le vent secouait les volets. Dans le couloir, une odeur de poussi√®re montait lentement.
Soudain, un grincement a travers√© la maison, comme une plainte. Je me suis fig√©.
‚Äî Qui est l√† ? ai-je souffl√©.
Le silence a r√©pondu, puis un pas a r√©sonn√© derri√®re la porte.
Je n‚Äôavais plus le choix : je devais agir.`
  },
  {
    title:"Texte support 2 (description ‚Äî court)",
    body:
`Le parc s‚Äô√©tendait au pied des immeubles. √Ä gauche, un banc √©caill√© attendait sous un platane.
Plus loin, la fontaine envoyait des √©clats d‚Äôeau froide. J‚Äôentendais des rires, puis le frottement des
baskets sur le gravier. L‚Äôair sentait l‚Äôherbe coup√©e, et une lumi√®re dor√©e glissait entre les branches.`
  }
];

const PROMPTS = [
  {
    id:"dialogue",
    title:"Qu√™te 1 ‚Äî Le duel de r√©pliques (Dialogue) ‚Äî 12 √† 18 lignes",
    consigne:
      "√âcris une sc√®ne o√π deux personnages se rencontrent dans un lieu pr√©cis (parc, gare, for√™t‚Ä¶). " +
      "Le dialogue doit faire avancer l‚Äôaction. Utilise au moins 3 verbes de parole diff√©rents et des incises.",
    points: 20,
    rules: [
      { key:"dialogueLines", label:"Tiret √† chaque changement de personnage", pts:6 },
      { key:"speechVerbs", label:"Au moins 3 verbes de parole vari√©s", pts:6 },
      { key:"incises", label:"Au moins 2 incises (ex : r√©pondit-il‚Ä¶)", pts:4 },
      { key:"actionWords", label:"Le dialogue fait avancer l‚Äôaction (mots d‚Äôaction)", pts:4 },
    ],
  },
  {
    id:"description",
    title:"Qu√™te 2 ‚Äî La carte du lieu (Description) ‚Äî 8 √† 12 lignes",
    consigne:
      "D√©cris un lieu en utilisant des verbes de perception (voir, entendre, sentir‚Ä¶) et des rep√®res spatiaux. " +
      "√âvite ‚Äúil y a‚Äù et ‚Äú√™tre‚Äù autant que possible.",
    points: 20,
    rules: [
      { key:"perceptionVerbs", label:"Au moins 3 verbes de perception", pts:7 },
      { key:"spatial", label:"Au moins 3 rep√®res spatiaux (√† gauche, derri√®re‚Ä¶)", pts:5 },
      { key:"avoidIlYa", label:"Peu de ‚Äúil y a‚Äù / ‚Äú√™tre‚Äù (bonus si peu)", pts:4 },
      { key:"richNounGroups", label:"Groupes nominaux enrichis (adjectifs/compl√©ments)", pts:4 },
    ],
  },
  {
    id:"connecteurs",
    title:"Qu√™te 3 ‚Äî Le pont des id√©es (Connecteurs) ‚Äî 10 √† 14 lignes",
    consigne:
      "Raconte un petit √©v√©nement et utilise au moins 6 connecteurs logiques, dont : 1 pour justifier, 1 pour opposer, 1 pour conclure.",
    points: 20,
    rules: [
      { key:"connectorsCount", label:"Au moins 6 connecteurs logiques", pts:8 },
      { key:"hasJustify", label:"Au moins 1 connecteur de justification", pts:4 },
      { key:"hasOppose", label:"Au moins 1 connecteur d‚Äôopposition", pts:4 },
      { key:"hasConclude", label:"Au moins 1 connecteur de conclusion", pts:4 },
    ],
  },
  {
    id:"poesie",
    title:"Qu√™te 4 ‚Äî Le sortil√®ge des vers (Po√©sie) ‚Äî 2 strophes",
    consigne:
      "√âcris un po√®me de 2 strophes (s√©par√©es par une ligne vide). Essaie un sch√©ma de rimes (AABB, ABAB ou ABBA). " +
      "Ajoute au moins une comparaison ou une m√©taphore.",
    points: 20,
    rules: [
      { key:"strophes", label:"2 strophes (ligne vide entre)", pts:6 },
      { key:"linesAsVers", label:"Au moins 8 vers au total", pts:6 },
      { key:"imagery", label:"Au moins 1 comparaison ou m√©taphore", pts:4 },
      { key:"sound", label:"Sonorit√©s (r√©p√©titions rep√©rables)", pts:4 },
    ],
  },
];

/* =========================================================
   4) ANALYSE AUTOMATIQUE (heuristique, utile)
========================================================= */
const CONNECTORS_FLAT = Object.values(LESSON.connecteurs).flat();
const JUSTIFY = LESSON.connecteurs["Expliquer / justifier"];
const OPPOSE  = LESSON.connecteurs["Opposer / nuancer"];
const CONCLUDE= LESSON.connecteurs["Conclure"];
const SPATIAL = ["ici","l√†-bas","la","devant","derriere","dessus","dessous","au-dessus","au-dessous","a gauche","a droite","plus loin","pres","au milieu","a travers","par-dessus","par-dessous","sur","sous","dans","contre"];
const PERCEPTION = ["voir","regarder","apercevoir","entendre","ecouter","sentir","respirer","toucher","palper","gouter","savourer","distinguer","remarquer"];
const SPEECH_VERBS = ["demander","questionner","interroger","repondre","repliquer","retorquer","s'exclamer","crier","murmurer","souffler","protester","acquiescer","balbutier","bafouiller","marteler","ordonner","chuchoter","avouer","ajouter"];
const ACTION_HINTS = ["court","courir","saisit","attrape","ouvre","ferme","recule","avance","tombe","fuit","frappe","pousse","tire","se leve","se tourne","entre","sort","cache","cherche","prend","pose"];

function norm(s){
  return (s||"")
    .toLowerCase()
    .replaceAll("‚Äô","'")
    .normalize("NFD").replace(/[\u0300-\u036f]/g,""); // sans accents
}
function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function uniqueFound(text, list){
  const t = norm(text);
  const found = [];
  for(const item of list){
    const it = norm(item);
    const re = new RegExp("(?:^|\\b|\\s)"+ escapeRegExp(it) +"(?:\\b|\\s|$)");
    if(re.test(t)) found.push(item);
  }
  return [...new Set(found)];
}

function analyze(text){
  const t = text || "";
  const tn = norm(t);
  const lines = t.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
  const blankLineCount = (t.match(/\n\s*\n/g)||[]).length;

  const dashLines = lines.filter(l => l.startsWith("-")).length;
  const incises = (tn.match(/\b(dit|repondit|demanda|ajouta|souffla|murmura|cria|protesta|retorqua)\b/g)||[]).length;

  const speechFound = uniqueFound(t, SPEECH_VERBS);
  const perceptionFound = uniqueFound(t, PERCEPTION);
  const spatialFound = uniqueFound(t, SPATIAL);

  const connectorsFound = uniqueFound(t, CONNECTORS_FLAT);
  const hasJustify = uniqueFound(t, JUSTIFY).length>0;
  const hasOppose  = uniqueFound(t, OPPOSE).length>0;
  const hasConclude= uniqueFound(t, CONCLUDE).length>0;

  const ilya = (tn.match(/\bil y a\b/g)||[]).length;
  const etre = (tn.match(/\b(etre|est|sont|etait|etaient|serait|sera|suis|es|sommes|etes)\b/g)||[]).length;

  const actionFound = uniqueFound(t, ACTION_HINTS);

  const versCount = lines.length;
  const strophes = blankLineCount >= 1 ? 2 : 1;

  const imagery = /\b(comme|tel|telle|pareil a|semblable a)\b/.test(tn) || /\bmetaphore\b/.test(tn);
  const words = tn.split(/[^a-zA-Z']+/).filter(w=>w.length>2);
  const freq = {};
  for(const w of words){ freq[w]=(freq[w]||0)+1; }
  const repeated = Object.entries(freq).filter(([w,c])=>c>=3 && !["pour","avec","dans","mais","plus","tres","bien"].includes(w)).map(([w])=>w);
  const sound = repeated.length>0;

  // Indice "GN enrichis" tr√®s l√©ger : adjectifs approximatifs
  const adjGuess = (tn.match(/\b\w+(?:eux|euse|if|ive|ant|ente|able|ible|ique|al|ale|elle|elles|es|e)\b/g)||[]).length;
  const richNounGroups = Math.min(1, Math.floor(adjGuess / 20));

  return {
    dashLines, incises,
    speechFound, perceptionFound, spatialFound,
    connectorsFound, hasJustify, hasOppose, hasConclude,
    ilya, etre, actionFound,
    versCount, strophes, imagery, sound, repeated,
    richNounGroups
  };
}

function scoreForPrompt(promptId, text){
  const p = PROMPTS.find(x=>x.id===promptId);
  const a = analyze(text);
  let score = 0;
  const detail = [];

  function add(pts, ok, why){
    if(ok){ score += pts; detail.push({ok:true, pts, why}); }
    else { detail.push({ok:false, pts, why}); }
  }

  if(promptId==="dialogue"){
    add(6, a.dashLines>=8, `Tirets (lignes commen√ßant par "-") : ${a.dashLines} (objectif ‚â• 8)`);
    add(6, a.speechFound.length>=3, `Verbes de parole vari√©s : ${a.speechFound.length} (${a.speechFound.join(", ")||"aucun"})`);
    add(4, a.incises>=2, `Incises rep√©r√©es : ${a.incises} (objectif ‚â• 2)`);
    add(4, a.actionFound.length>=3, `Action (indices) : ${a.actionFound.slice(0,6).join(", ") || "peu d‚Äôindices"}`);
  }

  if(promptId==="description"){
    add(7, a.perceptionFound.length>=3, `Verbes de perception : ${a.perceptionFound.length} (${a.perceptionFound.join(", ")||"aucun"})`);
    add(5, a.spatialFound.length>=3, `Rep√®res spatiaux : ${a.spatialFound.length} (${a.spatialFound.join(", ")||"aucun"})`);
    const okAvoid = (a.ilya<=1 && a.etre<=4);
    add(4, okAvoid, `‚Äúil y a‚Äù : ${a.ilya} | formes de ‚Äú√™tre‚Äù (approx) : ${a.etre} (objectif : peu)`);
    add(4, a.richNounGroups>=1, `Groupes nominaux enrichis (indice) : ${a.richNounGroups ? "ok" : "√† renforcer"}`);
  }

  if(promptId==="connecteurs"){
    add(8, a.connectorsFound.length>=6, `Connecteurs diff√©rents : ${a.connectorsFound.length} (${a.connectorsFound.join(", ")||"aucun"})`);
    add(4, a.hasJustify, `Justifier : ${a.hasJustify ? "ok" : "manque un connecteur (car / parce que / puisque‚Ä¶)"}`);
    add(4, a.hasOppose, `Opposer : ${a.hasOppose ? "ok" : "manque un connecteur (mais / pourtant / n√©anmoins‚Ä¶)"}`);
    add(4, a.hasConclude, `Conclure : ${a.hasConclude ? "ok" : "manque un connecteur (c‚Äôest pourquoi / par cons√©quent‚Ä¶)"}`);
  }

  if(promptId==="poesie"){
    add(6, a.strophes>=2, `Strophes : ${a.strophes} (objectif : 2, avec une ligne vide entre)`);
    add(6, a.versCount>=8, `Vers : ${a.versCount} (objectif ‚â• 8)`);
    add(4, a.imagery, `Image (comparaison/m√©taphore) : ${a.imagery ? "ok" : "ajoute ‚Äúcomme‚Äù, ‚Äútel‚Äù, ou une m√©taphore"}`);
    add(4, a.sound, `Sonorit√©s/r√©p√©titions : ${a.sound ? "ok" : "ajoute une r√©p√©tition (anaphore) ou une allit√©ration"}`);
  }

  score = Math.min(p.points, score);
  return { score, max:p.points, detail, analysis:a };
}

/* =========================================================
   5) √âTAT + STOCKAGE LOCAL
========================================================= */
const KEY="atelier_redac_6e_ludique_v2";
let state = loadState() || {
  name: "",
  qcmAnswers: {},       // index -> option
  workshopText: {},     // id -> text
  workshopScores: {},   // id -> {score,max,ts,detail,analysis}
  workshopAttempts: {}, // id -> nb corrections
  timeSpentSec: 0,      // temps total pass√©
  xp: 0,                // gamification
  badges: {},           // badgeId -> true
};

function saveState(){ localStorage.setItem(KEY, JSON.stringify(state)); }
function loadState(){ try{ return JSON.parse(localStorage.getItem(KEY)); }catch(e){ return null; } }
function resetAll(){
  state = {
    name:"", qcmAnswers:{}, workshopText:{}, workshopScores:{},
    workshopAttempts:{}, timeSpentSec:0, xp:0, badges:{}
  };
  saveState();
  render(currentTab);
  updateHeaderHUD();
  toast("üßπ Tout a √©t√© r√©initialis√© !");
}

/* =========================================================
   6) TEMPS PASS√â (actif) + format
========================================================= */
let lastTick = Date.now();
let active = true;
let lastActivity = Date.now();
function markActivity(){ lastActivity = Date.now(); }
["click","keydown","mousemove","touchstart","scroll"].forEach(ev=>{
  window.addEventListener(ev, markActivity, {passive:true});
});
document.addEventListener("visibilitychange", ()=>{
  active = !document.hidden;
  lastTick = Date.now();
});
setInterval(()=>{
  const now = Date.now();
  const dt = (now - lastTick) / 1000;
  lastTick = now;
  const recentlyActive = (now - lastActivity) < 60000;
  if(active && recentlyActive){
    state.timeSpentSec = (state.timeSpentSec || 0) + dt;
    saveState();
    // pas de render en boucle (on reste light)
  }
}, 1000);

function formatTime(sec){
  sec = Math.floor(sec || 0);
  const h = Math.floor(sec/3600);
  const m = Math.floor((sec%3600)/60);
  const s = sec%60;
  if(h>0) return `${h}h ${m}min`;
  if(m>0) return `${m}min ${s}s`;
  return `${s}s`;
}

/* =========================================================
   7) NOTE /20 + appr√©ciation + feux d√©taill√©s
========================================================= */
function computeQcmScore(){
  let score=0, answered=0;
  for(let i=0;i<QCM.length;i++){
    if(state.qcmAnswers[i]!==undefined){
      answered++;
      if(state.qcmAnswers[i]===QCM[i].answer) score++;
    }
  }
  return { score, max:QCM.length, done: answered===QCM.length };
}
function computeWorkshopTotal(){
  let score=0, max=0, doneCount=0;
  for(const p of PROMPTS){
    max += p.points;
    const s = state.workshopScores[p.id];
    if(s){ score += s.score; doneCount++; }
  }
  return { score, max, doneCount };
}

function computeGradeOn20(){
  const q = computeQcmScore();      // /7
  const w = computeWorkshopTotal(); // /80
  const qPart = q.max ? (q.score/q.max)*4 : 0;
  const wPart = w.max ? (w.score/w.max)*16 : 0;
  const grade = Math.round((qPart+wPart)*10)/10;
  return { grade, qPart: Math.round(qPart*10)/10, wPart: Math.round(wPart*10)/10 };
}
function appreciationFromGrade(g){
  if(g >= 16) return "Tr√®s bon travail : m√©thode acquise, consignes respect√©es, progr√®s visibles.";
  if(g >= 13) return "Bon travail : solide, mais encore des points √† renforcer (voir les feux).";
  if(g >= 10) return "Travail moyen : les bases sont l√†, mais il faut reprendre la le√ßon et refaire au moins 2 qu√™tes.";
  return "Insuffisant : reprendre la le√ßon, refaire le QCM, puis r√©√©crire les qu√™tes avec correction.";
}

function skillLightsDetailed(){
  const get = (id)=>{
    const s = state.workshopScores[id];
    if(!s) return null;
    const pct = s.max ? (s.score/s.max) : 0;
    return { pct, score:s.score, max:s.max };
  };
  function light(o, hint){
    if(!o) return { icon:"‚ö™", txt:"non fait", hint:"Fais l‚Äôexercice puis corrige-le." };
    if(o.pct >= .8) return { icon:"üü¢", txt:"acquis", hint:"Continue comme √ßa." };
    if(o.pct >= .5) return { icon:"üü†", txt:"√† renforcer", hint };
    return { icon:"üî¥", txt:"√† reprendre", hint };
  }
  const hints = {
    dialogue: "Ajoute des tirets √† chaque r√©plique, 2 incises, et 3 verbes de parole vari√©s.",
    description: "Ajoute 3 verbes de perception + 3 rep√®res spatiaux et limite ‚Äúil y a / √™tre‚Äù.",
    connecteurs: "Mets au moins 6 connecteurs + ‚Äúcar‚Äù + ‚Äún√©anmoins‚Äù + ‚Äúc‚Äôest pourquoi‚Äù.",
    poesie: "Fais 2 strophes (ligne vide) + 8 vers + une comparaison (‚Äúcomme‚Ä¶‚Äù)."
  };
  return {
    dialogue: light(get("dialogue"), hints.dialogue),
    description: light(get("description"), hints.description),
    connecteurs: light(get("connecteurs"), hints.connecteurs),
    poesie: light(get("poesie"), hints.poesie),
  };
}

/* =========================================================
   8) LUDIQUE : XP, niveaux, badges
========================================================= */
function levelFromXp(xp){
  // progression simple : niveau n = somme (n*60)
  let level = 1;
  let need = 60;
  let remaining = xp;
  while(remaining >= need){
    remaining -= need;
    level++;
    need = 60 + (level-1)*20;
  }
  const nextNeed = need;
  const progress = Math.round((remaining / nextNeed) * 100);
  return { level, remaining, nextNeed, progress };
}

function addXp(amount, reason){
  amount = Math.max(0, Math.floor(amount));
  const before = levelFromXp(state.xp||0).level;
  state.xp = (state.xp||0) + amount;
  saveState();
  const after = levelFromXp(state.xp||0).level;
  updateHeaderHUD();
  if(amount>0) toast(`‚ú® +${amount} XP ‚Äî ${reason}`);
  if(after > before) toast(`üèÜ Niveau ${after} atteint !`);
  checkBadges();
}

function awardBadge(id, title){
  if(state.badges && state.badges[id]) return;
  state.badges = state.badges || {};
  state.badges[id] = true;
  saveState();
  toast(`üèÖ Badge d√©bloqu√© : ${title}`);
}

function checkBadges(){
  const q = computeQcmScore();
  const w = computeWorkshopTotal();
  const lights = skillLightsDetailed();

  if(q.done && q.score===q.max) awardBadge("qcm_perfect", "Sans faute au QCM");
  if(q.done) awardBadge("qcm_done", "QCM termin√©");
  if(w.doneCount>=1) awardBadge("first_quest", "Premi√®re qu√™te corrig√©e");
  if(w.doneCount===PROMPTS.length) awardBadge("all_quests", "Toutes les qu√™tes corrig√©es");

  // 16/20 ou plus
  const g = computeGradeOn20().grade;
  if(g>=16) awardBadge("grade_16", "Note parent ‚â• 16/20");

  // Feux verts partout (si tout fait + acquis)
  if(lights.dialogue.icon==="üü¢" && lights.description.icon==="üü¢" && lights.connecteurs.icon==="üü¢" && lights.poesie.icon==="üü¢"){
    awardBadge("all_green", "Tout au vert");
  }
}

function updateHeaderHUD(){
  const xpEl = document.getElementById("xp");
  const levelEl = document.getElementById("level");
  const l = levelFromXp(state.xp||0);
  if(xpEl) xpEl.textContent = String(state.xp||0);
  if(levelEl) levelEl.textContent = String(l.level);
}

/* =========================================================
   9) UI / NAV
========================================================= */
const view = document.getElementById("view");
const toastEl = document.getElementById("toast");
function toast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  setTimeout(()=>toastEl.classList.remove("show"), 2600);
}

let currentTab="lesson";
document.querySelectorAll(".tab").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    currentTab = btn.dataset.tab;
    render(currentTab);
  });
});

function escapeHtml(str){
  return (str||"").replace(/[&<>"']/g, m=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}

function render(tab){
  if(tab==="lesson") renderLesson();
  if(tab==="qcm") renderQCM();
  if(tab==="workshops") renderWorkshops();
  if(tab==="report") renderReport();
  updateHeaderHUD();
}

/* =========================================================
   10) WIDGETS : points + barre de progression + badges
========================================================= */
function renderPointsWidget(){
  const qcm = computeQcmScore();
  const ws  = computeWorkshopTotal();
  const total = qcm.score + ws.score;
  const max = qcm.max + ws.max;

  const grade = computeGradeOn20();
  const lvl = levelFromXp(state.xp||0);

  return `
    <div class="banner">
      <div class="row" style="justify-content:space-between; gap:12px;">
        <div>
          <div class="small">Progression aventure</div>
          <div class="pill">üèÜ Note parent : <span class="score" style="margin-left:6px">${grade.grade} / 20</span></div>
          <div class="small">QCM ${qcm.score}/${qcm.max} ‚Ä¢ Qu√™tes ${ws.score}/${ws.max} ‚Ä¢ Total ${total}/${max}</div>
        </div>
        <div style="min-width:240px; width:320px; max-width:100%;">
          <div class="small">Niveau ${lvl.level} ‚Äî ${lvl.remaining}/${lvl.nextNeed} XP</div>
          <div class="progress"><div style="width:${lvl.progress}%"></div></div>
        </div>
      </div>
    </div>
  `;
}

function renderBadges(){
  const all = [
    ["qcm_done","QCM termin√©"],
    ["qcm_perfect","Sans faute au QCM"],
    ["first_quest","Premi√®re qu√™te corrig√©e"],
    ["all_quests","Toutes les qu√™tes corrig√©es"],
    ["grade_16","Note ‚â• 16/20"],
    ["all_green","Tout au vert"],
  ];
  const got = state.badges || {};
  return `
    <div class="row">
      ${all.map(([id,label])=>{
        const ok = !!got[id];
        return `<span class="badge" title="${escapeHtml(label)}">${ok ? "üèÖ" : "üîí"} ${escapeHtml(label)}</span>`;
      }).join("")}
    </div>
  `;
}

/* =========================================================
   11) PAGE : LE√áON
========================================================= */
function renderLesson(){
  view.innerHTML = `
  <div class="grid">
    <div class="card">
      <h2>üìö Le√ßon (le grimoire du r√©dacteur)</h2>
      <p class="muted">Lis vite fait, puis passe aux qu√™tes. Le but : √©crire mieux, pas rester bloqu√© sur la th√©orie.</p>

      ${renderPointsWidget()}

      <div class="hr"></div>

      <h3>üß† M√©thode (brouillon ‚Üí plan ‚Üí r√©daction ‚Üí relecture)</h3>
      <ul class="muted">${LESSON.methode.map(x=>`<li>${x}</li>`).join("")}</ul>

      <h3>üí¨ Dialogue dans un r√©cit</h3>
      <ul class="muted">${LESSON.dialogue.map(x=>`<li>${x}</li>`).join("")}</ul>

      <h3>üñºÔ∏è Description</h3>
      <ul class="muted">${LESSON.description.map(x=>`<li>${x}</li>`).join("")}</ul>

      <h3>üîó Connecteurs logiques (banque)</h3>
      ${Object.entries(LESSON.connecteurs).map(([k,v])=>`
        <details>
          <summary>${escapeHtml(k)}</summary>
          <div class="small">${v.map(w=>`<span class="tag">${escapeHtml(w)}</span>`).join(" ")}</div>
        </details>
      `).join("<div class='hr'></div>")}

      <h3>üé≠ Po√©sie (bases)</h3>
      <ul class="muted">${LESSON.poesie.map(x=>`<li>${x}</li>`).join("")}</ul>

      <div class="hr"></div>
      <h3>üèÖ Badges</h3>
      ${renderBadges()}
    </div>

    <div class="card">
      <h2>üë§ Profil √©l√®ve</h2>
      <p class="muted">Entre le pr√©nom de ton fils (√ßa reste sur l‚Äôappareil).</p>
      <input id="name" type="text" placeholder="Pr√©nom" value="${escapeHtml(state.name||"")}" />
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="saveName">Enregistrer</button>
        <button class="btn danger" id="resetAll">Tout r√©initialiser</button>
      </div>

      <div class="hr"></div>
      <h2>üéÆ Mini-objectif du jour</h2>
      <div class="q">
        <div class="stem">Mission √©clair</div>
        <div class="muted">Fais le QCM + corrige au moins 1 qu√™te. Objectif : <b>+120 XP</b>.</div>
        <div class="small">Astuce : corriger 2 fois la m√™me qu√™te, c‚Äôest bien (am√©lioration r√©elle).</div>
      </div>

      <div class="hr"></div>
      <h2>‚è±Ô∏è Temps pass√©</h2>
      <div class="pill">Temps actif : <b id="timeSpent">${escapeHtml(formatTime(state.timeSpentSec||0))}</b></div>
      <div class="small" style="margin-top:8px;">Le temps se cumule quand l‚Äôonglet est visible + activit√© r√©cente.</div>
    </div>
  </div>
  `;

  document.getElementById("saveName").onclick = ()=>{
    state.name = document.getElementById("name").value.trim();
    saveState();
    toast("‚úÖ Pr√©nom enregistr√©");
    render("lesson");
  };
  document.getElementById("resetAll").onclick = ()=>{
    if(confirm("Tout effacer (nom, QCM, qu√™tes, points, temps) ?")) resetAll();
  };

  // petit refresh du temps sans re-render complet
  const timeEl = document.getElementById("timeSpent");
  if(timeEl){
    const id = setInterval(()=>{
      timeEl.textContent = formatTime(state.timeSpentSec||0);
    }, 1000);
    // stop interval if tab changed (simple)
    setTimeout(()=>clearInterval(id), 20000);
  }
}

/* =========================================================
   12) PAGE : QCM
========================================================= */
function renderQuestion(q, idx){
  const chosen = state.qcmAnswers[idx];
  return `
    <div class="q">
      <div class="stem">${idx+1}. <span class="tag">${escapeHtml(q.cat)}</span> ${escapeHtml(q.stem)}</div>
      ${q.options.map((opt, i)=>`
        <label class="opt">
          <input type="radio" name="q${idx}" value="${i}" ${chosen===i?'checked':''} />
          <span>${escapeHtml(opt)}</span>
        </label>
      `).join("")}
    </div>
  `;
}

function renderQCM(){
  const qcm = computeQcmScore();
  view.innerHTML = `
  <div class="grid">
    <div class="card">
      <h2>‚úÖ QCM (le portail de la connaissance)</h2>
      <p class="muted">R√©ponds √† tout, puis clique ‚ÄúCorrig√©‚Äù. Bonus XP si tu fais un sans-faute.</p>

      ${renderPointsWidget()}

      <div class="hr"></div>

      ${QCM.map((q, idx)=>renderQuestion(q, idx)).join("")}

      <div class="row" style="margin-top:12px;">
        <button class="btn primary" id="showScore">Corrig√© + Score</button>
        <span class="pill">Score actuel : <span class="score" style="margin-left:6px">${qcm.score} / ${qcm.max}</span></span>
      </div>

      <div id="qcmFeedback" style="margin-top:12px;"></div>
    </div>

    <div class="card">
      <h2>üéØ Conseils rapides</h2>
      <div class="q">
        <div class="stem">Pour gagner</div>
        <div class="muted">
          Dialogue : tirets + verbes de parole vari√©s.<br/>
          Description : perception + rep√®res spatiaux.<br/>
          Connecteurs : car / n√©anmoins / c‚Äôest pourquoi.<br/>
          Po√©sie : 2 strophes, 8 vers, image ‚Äúcomme‚Ä¶‚Äù.
        </div>
      </div>
      <div class="hr"></div>
      <h2>üèÖ Badges</h2>
      ${renderBadges()}
    </div>
  </div>
  `;

  // bind radios
  QCM.forEach((q, idx)=>{
    const name = `q${idx}`;
    const radios = document.querySelectorAll(`input[name="${name}"]`);
    radios.forEach(r=>{
      r.addEventListener("change", ()=>{
        state.qcmAnswers[idx] = parseInt(r.value,10);
        saveState();
      });
    });
  });

  document.getElementById("showScore").onclick = ()=>{
    const s = computeQcmScore();
    const fb = document.getElementById("qcmFeedback");
    if(!s.done){
      fb.innerHTML = `<div class="q"><div class="stem warn">‚ö†Ô∏è Il manque des r√©ponses. R√©ponds √† tout pour valider le QCM.</div></div>`;
      toast("‚ö†Ô∏è R√©ponds √† toutes les questions !");
      return;
    }

    const corrections = QCM.map((q, idx)=>{
      const chosen = state.qcmAnswers[idx];
      const ok = chosen===q.answer;
      return `
        <div class="q">
          <div class="stem">${idx+1}. <span class="tag">${escapeHtml(q.cat)}</span> ${escapeHtml(q.stem)}</div>
          <div class="${ok?'good':'bad'}"><b>${ok?'‚úî Correct':'‚úò Faux'}</b> ‚Äî Ta r√©ponse : ${escapeHtml(q.options[chosen])}</div>
          <div class="small">Correction : ${escapeHtml(q.options[q.answer])}. ${escapeHtml(q.explain)}</div>
        </div>
      `;
    }).join("");

    fb.innerHTML = `
      <div class="q">
        <div class="stem">üéØ R√©sultat : <span class="score">${s.score} / ${s.max}</span></div>
        <div class="small">Chaque bonne r√©ponse vaut 1 point.</div>
      </div>
      ${corrections}
    `;

    // XP
    const baseXp = 60;
    const bonus = (s.score===s.max) ? 40 : 0;
    addXp(baseXp + Math.floor(s.score*5) + bonus, bonus? "QCM parfait üéâ" : "QCM termin√©");
    checkBadges();
    render("qcm"); // refresh HUD/badges
  };
}

/* =========================================================
   13) PAGE : ATELIERS (qu√™tes)
========================================================= */
function renderWorkshopBlock(p){
  const saved = state.workshopScores[p.id];
  const attempts = state.workshopAttempts[p.id] || 0;

  let fbHtml = `<div class="small">Pas encore corrig√©. √âcris puis clique ‚ÄúCorriger‚Äù.</div>`;
  if(saved){
    fbHtml = `
      <div class="q" id="fb_${p.id}">
        <div class="stem">üéØ Score : <span class="score">${saved.score} / ${saved.max}</span>
          <span class="small">(${new Date(saved.ts).toLocaleString()})</span>
          <span class="tag">Corrections : ${attempts}</span>
        </div>
        ${saved.detail.map(d=>`
          <div class="${d.ok?'good':'bad'}"><b>${d.ok?'‚úî':'‚úò'}</b> (${d.pts} pts) ‚Äî ${escapeHtml(d.why)}</div>
        `).join("")}
        <div class="hr"></div>
        <div class="small">
          Connecteurs trouv√©s : ${escapeHtml((saved.analysis.connectorsFound||[]).join(", ") || "‚Äî")}<br/>
          Perception : ${escapeHtml((saved.analysis.perceptionFound||[]).join(", ") || "‚Äî")}<br/>
          Spatial : ${escapeHtml((saved.analysis.spatialFound||[]).join(", ") || "‚Äî")}<br/>
          Verbes de parole : ${escapeHtml((saved.analysis.speechFound||[]).join(", ") || "‚Äî")}
        </div>
      </div>
    `;
  }

  const existing = state.workshopText[p.id] || "";

  return `
    <div class="q">
      <div class="stem">${escapeHtml(p.title)} <span class="tag">${p.points} pts</span> <span class="tag">Corrections : ${attempts}</span></div>
      <div class="muted">${escapeHtml(p.consigne)}</div>
      <div class="small" style="margin-top:8px;">Crit√®res :</div>
      <div class="small">${p.rules.map(r=>`<span class="tag">${escapeHtml(r.label)} (${r.pts})</span>`).join(" ")}</div>

      <div style="margin-top:10px;">
        <textarea id="ta_${p.id}" placeholder="√âcris ton texte ici‚Ä¶">${escapeHtml(existing)}</textarea>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="corr_${p.id}">Corriger & noter</button>
        <button class="btn secondary" id="hint_${p.id}">Indice</button>
        <span class="pill">Objectif : am√©liorer ton score</span>
      </div>

      <div id="hintbox_${p.id}" style="margin-top:10px;"></div>
      <div style="margin-top:10px;">${fbHtml}</div>
    </div>
  `;
}

function renderWorkshops(){
  const lights = skillLightsDetailed();
  view.innerHTML = `
  <div class="grid">
    <div class="card">
      <h2>‚úçÔ∏è Qu√™tes d‚Äô√©criture (corrig√©es automatiquement)</h2>
      <p class="muted">
        Tu √©cris, puis tu corriges : le score v√©rifie des crit√®res objectifs (structure, connecteurs, rep√®res‚Ä¶).
        Ce n‚Äôest pas un prof, mais c‚Äôest excellent pour r√©viser la le√ßon.
      </p>

      ${renderPointsWidget()}

      <div class="hr"></div>

      <div class="q">
        <div class="stem">üö¶ Feux tricolores</div>
        <div class="small">
          ${lights.dialogue.icon} Dialogue : <b>${lights.dialogue.txt}</b> ‚Äî ${escapeHtml(lights.dialogue.hint)}<br/>
          ${lights.description.icon} Description : <b>${lights.description.txt}</b> ‚Äî ${escapeHtml(lights.description.hint)}<br/>
          ${lights.connecteurs.icon} Connecteurs : <b>${lights.connecteurs.txt}</b> ‚Äî ${escapeHtml(lights.connecteurs.hint)}<br/>
          ${lights.poesie.icon} Po√©sie : <b>${lights.poesie.txt}</b> ‚Äî ${escapeHtml(lights.poesie.hint)}
        </div>
      </div>

      <h3>üìñ Textes supports (√† √©tudier)</h3>
      ${TEXTS.map(t=>`
        <details>
          <summary>${escapeHtml(t.title)}</summary>
          <pre class="mono" style="white-space:pre-wrap; color:#dbe7ff">${escapeHtml(t.body)}</pre>
        </details>
      `).join("<div class='hr'></div>")}

      <div class="hr"></div>

      ${PROMPTS.map(p=>renderWorkshopBlock(p)).join("<div class='hr'></div>")}
    </div>

    <div class="card">
      <h2>üß™ Boost de score (tr√®s simple)</h2>
      <div class="q">
        <div class="stem">Trucs qui donnent des points</div>
        <div class="muted">
          <b>Dialogue :</b> 8 lignes avec ‚Äú-‚Äù + 2 incises + 3 verbes de parole.<br/>
          <b>Description :</b> 3 perceptions + 3 rep√®res (√† gauche, derri√®re‚Ä¶) + peu de ‚Äúil y a/√™tre‚Äù.<br/>
          <b>Connecteurs :</b> 6 connecteurs + ‚Äúcar‚Äù + ‚Äún√©anmoins‚Äù + ‚Äúc‚Äôest pourquoi‚Äù.<br/>
          <b>Po√©sie :</b> 2 strophes (ligne vide) + 8 vers + ‚Äúcomme‚Ä¶‚Äù.
        </div>
      </div>

      <div class="hr"></div>
      <h2>‚è±Ô∏è Travail</h2>
      <div class="pill">Temps actif : <b>${escapeHtml(formatTime(state.timeSpentSec||0))}</b></div>
      <div class="small" style="margin-top:8px;">
        Corrections totales : <b>${Object.values(state.workshopAttempts||{}).reduce((a,b)=>a+(b||0),0)}</b>
      </div>

      <div class="hr"></div>
      <h2>üèÖ Badges</h2>
      ${renderBadges()}
    </div>
  </div>
  `;

  // bind inputs & buttons
  PROMPTS.forEach(p=>{
    const ta = document.getElementById(`ta_${p.id}`);
    if(ta){
      ta.addEventListener("input", ()=>{
        state.workshopText[p.id] = ta.value;
        saveState();
      });
    }

    const hintBtn = document.getElementById(`hint_${p.id}`);
    if(hintBtn){
      hintBtn.onclick = ()=>{
        const lights = skillLightsDetailed();
        const hint = lights[p.id]?.hint || "Relis la le√ßon et ajoute ce qui manque.";
        const box = document.getElementById(`hintbox_${p.id}`);
        box.innerHTML = `
          <div class="q">
            <div class="stem">üß© Indice</div>
            <div class="muted">${escapeHtml(hint)}</div>
          </div>
        `;
        addXp(5, "Indice consult√©");
      };
    }

    const btn = document.getElementById(`corr_${p.id}`);
    if(btn){
      btn.onclick = ()=>{
        const text = (state.workshopText[p.id] || "").trim();
        if(text.length < 30){
          toast("‚ö†Ô∏è √âcris un peu plus (au moins 2‚Äì3 phrases).");
          return;
        }
        const before = state.workshopScores[p.id]?.score ?? null;
        const res = scoreForPrompt(p.id, text);

        state.workshopScores[p.id] = { ...res, ts: new Date().toISOString() };
        state.workshopAttempts[p.id] = (state.workshopAttempts[p.id] || 0) + 1;
        saveState();

        // XP : base + bonus am√©lioration
        const base = 35;
        const improved = (before!==null) ? Math.max(0, res.score - before) : res.score;
        addXp(base + Math.floor(improved*3), "Qu√™te corrig√©e");

        checkBadges();
        render("workshops");

        const fb = document.getElementById(`fb_${p.id}`);
        if(fb) fb.scrollIntoView({behavior:"smooth", block:"start"});
      };
    }
  });
}

/* =========================================================
   14) PAGE : BILAN PARENT + EXPORT + RAPPORT IMPRIMABLE
========================================================= */
function download(filename, text, mime){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

function makeReportText(){
  const q = computeQcmScore();
  const w = computeWorkshopTotal();
  const g = computeGradeOn20();
  const lights = skillLightsDetailed();
  const total = q.score + w.score;
  const max = q.max + w.max;
  const attemptsTotal = Object.values(state.workshopAttempts||{}).reduce((a,b)=>a+(b||0),0);

  let out = "";
  out += `RAPPORT PARENT ‚Äî Atelier R√©daction 6e\n`;
  out += `√âl√®ve : ${state.name || "(non renseign√©)"}\n`;
  out += `Date : ${new Date().toLocaleString()}\n\n`;
  out += `QCM : ${q.score}/${q.max}\n`;
  out += `Ateliers : ${w.score}/${w.max}\n`;
  out += `TOTAL : ${total}/${max}\n`;
  out += `NOTE PARENT : ${g.grade}/20 (QCM ${g.qPart}/4 + Ateliers ${g.wPart}/16)\n`;
  out += `Temps actif : ${formatTime(state.timeSpentSec||0)}\n`;
  out += `Corrections : ${attemptsTotal}\n\n`;
  out += `Feux (comp√©tences):\n`;
  out += `- Dialogue : ${lights.dialogue.icon} ${lights.dialogue.txt} ‚Äî ${lights.dialogue.hint}\n`;
  out += `- Description : ${lights.description.icon} ${lights.description.txt} ‚Äî ${lights.description.hint}\n`;
  out += `- Connecteurs : ${lights.connecteurs.icon} ${lights.connecteurs.txt} ‚Äî ${lights.connecteurs.hint}\n`;
  out += `- Po√©sie : ${lights.poesie.icon} ${lights.poesie.txt} ‚Äî ${lights.poesie.hint}\n\n`;
  out += `Appr√©ciation : ${appreciationFromGrade(g.grade)}\n\n`;
  out += `Note : la correction automatique v√©rifie surtout des crit√®res objectifs (structure, connecteurs, indices). Le style/creativit√© est humain.\n`;
  return out;
}

function parentReportHtml(){
  const q = computeQcmScore();
  const w = computeWorkshopTotal();
  const g = computeGradeOn20();
  const lights = skillLightsDetailed();
  const total = q.score + w.score;
  const max = q.max + w.max;
  const attempts = state.workshopAttempts || {};
  const timeStr = formatTime(state.timeSpentSec||0);

  function row(title, id){
    const s = state.workshopScores[id];
    const a = attempts[id] || 0;
    const L = lights[id];
    if(!s) return `<tr><td>${title}</td><td>‚Äî</td><td>${a}</td><td>${L.icon} ${L.txt}</td></tr>`;
    return `<tr><td>${title}</td><td>${s.score} / ${s.max}</td><td>${a}</td><td>${L.icon} ${L.txt}</td></tr>`;
  }

  return `
<!doctype html>
<html lang="fr"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Rapport parent ‚Äî R√©daction 6e</title>
<style>
  body{font-family:Arial, sans-serif; padding:18px; color:#111;}
  h1{font-size:18px; margin:0 0 6px;}
  .muted{color:#555; font-size:12px;}
  .box{border:1px solid #ddd; padding:12px; border-radius:10px; margin:12px 0;}
  table{border-collapse:collapse; width:100%;}
  th,td{border:1px solid #ddd; padding:8px; font-size:13px; text-align:left;}
  th{background:#f5f5f5;}
  .kpi{display:flex; gap:10px; flex-wrap:wrap;}
  .kpi div{border:1px solid #ddd; border-radius:10px; padding:10px 12px; min-width:160px;}
  .big{font-size:16px; font-weight:700;}
  @media print{ button{display:none;} body{padding:0;} }
</style>
</head><body>
<button onclick="window.print()">Imprimer</button>
<h1>Rapport parent ‚Äî Atelier R√©daction 6e</h1>
<div class="muted">√âl√®ve : <b>${(state.name || "Non renseign√©")}</b> ‚Äî Date : ${new Date().toLocaleString()}</div>

<div class="box kpi">
  <div><div class="muted">QCM</div><div class="big">${q.score} / ${q.max}</div></div>
  <div><div class="muted">Ateliers</div><div class="big">${w.score} / ${w.max}</div></div>
  <div><div class="muted">Total</div><div class="big">${total} / ${max}</div></div>
  <div><div class="muted">Note parent</div><div class="big">${g.grade} / 20</div></div>
  <div><div class="muted">Temps pass√©</div><div class="big">${timeStr}</div></div>
</div>

<div class="box">
  <h2 style="font-size:15px;margin:0 0 8px;">Appr√©ciation</h2>
  <div>${appreciationFromGrade(g.grade)}</div>
</div>

<div class="box">
  <h2 style="font-size:15px;margin:0 0 8px;">Comp√©tences (feux)</h2>
  <ul style="margin:0; padding-left:18px; font-size:13px;">
    <li>${lights.dialogue.icon} Dialogue : <b>${lights.dialogue.txt}</b> ‚Äî ${lights.dialogue.hint}</li>
    <li>${lights.description.icon} Description : <b>${lights.description.txt}</b> ‚Äî ${lights.description.hint}</li>
    <li>${lights.connecteurs.icon} Connecteurs : <b>${lights.connecteurs.txt}</b> ‚Äî ${lights.connecteurs.hint}</li>
    <li>${lights.poesie.icon} Po√©sie : <b>${lights.poesie.txt}</b> ‚Äî ${lights.poesie.hint}</li>
  </ul>
</div>

<div class="box">
  <h2 style="font-size:15px;margin:0 0 8px;">D√©tail qu√™tes</h2>
  <table>
    <thead><tr><th>Qu√™te</th><th>Score</th><th>Corrections</th><th>Niveau</th></tr></thead>
    <tbody>
      ${row("Qu√™te 1 ‚Äî Dialogue", "dialogue")}
      ${row("Qu√™te 2 ‚Äî Description", "description")}
      ${row("Qu√™te 3 ‚Äî Connecteurs", "connecteurs")}
      ${row("Qu√™te 4 ‚Äî Po√©sie", "poesie")}
    </tbody>
  </table>
</div>

<div class="muted">
  Note : la correction automatique v√©rifie surtout des crit√®res objectifs (structure, connecteurs, indices). Le style et la cr√©ativit√© restent √† juger humainement.
</div>
</body></html>
  `;
}

function openParentReport(){
  const html = parentReportHtml();
  const w = window.open("", "_blank");
  if(!w){ alert("Le navigateur a bloqu√© la fen√™tre. Autorise les popups pour imprimer le rapport."); return; }
  w.document.open(); w.document.write(html); w.document.close();
}

function renderReport(){
  const q = computeQcmScore();
  const w = computeWorkshopTotal();
  const g = computeGradeOn20();
  const lights = skillLightsDetailed();
  const total = q.score + w.score;
  const max = q.max + w.max;
  const attemptsTotal = Object.values(state.workshopAttempts||{}).reduce((a,b)=>a+(b||0),0);
  const timeStr = formatTime(state.timeSpentSec||0);

  view.innerHTML = `
  <div class="grid">
    <div class="card">
      <h2>üèÅ Bilan Parent (clair et v√©rifiable)</h2>
      <p class="muted">Ici tu as une note sur 20 + les feux + le temps + le nombre de corrections.</p>

      ${renderPointsWidget()}

      <div class="hr"></div>

      <div class="q">
        <div class="stem">üßæ Note parent : <span class="score">${g.grade} / 20</span></div>
        <div class="small">D√©tail : QCM ${g.qPart}/4 + Qu√™tes ${g.wPart}/16</div>
        <div class="small"><b>Appr√©ciation :</b> ${escapeHtml(appreciationFromGrade(g.grade))}</div>
      </div>

      <div class="q">
        <div class="stem">‚è±Ô∏è Travail</div>
        <div class="small">Temps actif : <b>${escapeHtml(timeStr)}</b> ‚Äî Corrections : <b>${attemptsTotal}</b></div>
      </div>

      <div class="q">
        <div class="stem">üö¶ Feux (comp√©tences)</div>
        <div class="small">
          ${lights.dialogue.icon} Dialogue : <b>${lights.dialogue.txt}</b> ‚Äî ${escapeHtml(lights.dialogue.hint)}<br/>
          ${lights.description.icon} Description : <b>${lights.description.txt}</b> ‚Äî ${escapeHtml(lights.description.hint)}<br/>
          ${lights.connecteurs.icon} Connecteurs : <b>${lights.connecteurs.txt}</b> ‚Äî ${escapeHtml(lights.connecteurs.hint)}<br/>
          ${lights.poesie.icon} Po√©sie : <b>${lights.poesie.txt}</b> ‚Äî ${escapeHtml(lights.poesie.hint)}
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="exportTxt">Exporter rapport (.txt)</button>
        <button class="btn" id="exportJson">Exporter donn√©es (.json)</button>
        <button class="btn primary" id="parentPrint">Rapport parent (imprimer)</button>
      </div>

      <div id="exportBox" style="margin-top:12px;"></div>
    </div>

    <div class="card">
      <h2>üèÖ Badges</h2>
      ${renderBadges()}

      <div class="hr"></div>
      <h2>üéÅ Bonus ludique</h2>
      <div class="q">
        <div class="stem">R√©compenses</div>
        <div class="muted">
          ‚úÖ QCM termin√© : +60 XP<br/>
          ‚ú® QCM sans faute : +40 XP<br/>
          ‚úçÔ∏è Chaque qu√™te corrig√©e : +35 XP + bonus am√©lioration<br/>
          üß© Indice : +5 XP
        </div>
      </div>

      <div class="hr"></div>
      <h2>üìå Limite honn√™te</h2>
      <p class="muted">
        La note automatique v√©rifie des indices (structure, mots, connecteurs). Elle ne juge pas la beaut√© du style.
        Mais pour r√©viser la le√ßon de m√©thode, c‚Äôest tr√®s efficace.
      </p>
    </div>
  </div>
  `;

  document.getElementById("exportTxt").onclick = ()=>{
    const txt = makeReportText();
    download("rapport_parent_redaction_6e.txt", txt, "text/plain");
    document.getElementById("exportBox").innerHTML =
      `<pre class="mono" style="white-space:pre-wrap">${escapeHtml(txt)}</pre>`;
    addXp(10, "Rapport export√©");
  };
  document.getElementById("exportJson").onclick = ()=>{
    const data = JSON.stringify(state, null, 2);
    download("donnees_redaction_6e.json", data, "application/json");
    document.getElementById("exportBox").innerHTML =
      `<pre class="mono" style="white-space:pre-wrap">${escapeHtml(data)}</pre>`;
    addXp(10, "Donn√©es export√©es");
  };
  document.getElementById("parentPrint").onclick = ()=> openParentReport();
}

/* =========================================================
   15) INIT
========================================================= */
updateHeaderHUD();
checkBadges();
render(currentTab);
</script>
</body>
</html>
